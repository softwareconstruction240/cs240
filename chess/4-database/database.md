# ♕ Phase 4: Chess Database

- [Chess Application Overview](../chess.md)
- [Getting Started](getting-started.md)
- 🖥️ [Videos](#videos)

In this part of the Chess project, you will create a MySQL implementation of your Data Access interface and start calling it from your services. This enables the ability to store data persistently in a MySQL database instead of storing data in main memory. You will also write unit tests using JUnit for your DAO classes. This involves the following steps:

1. Install the MYSQL database management system (DBMS) on your development machine.
1. Modify `db.properties` to contain your username and password.
1. Design your database tables (i.e., your database `schema`)
1. Implement a MySQL implementation of your Data Access Interface. Initially you can just stub out all of the methods.
1. Add the ability to create your database and tables, if they don't exist, when your server starts up.
1. Iteratively write a test for each of your Data Access interface methods along with the backing MySQL code.
1. Ensure that all provided pass off tests work properly, including the DatabaseTests added for this assignment, and the StandardAPITests from the previous assignment.

## Making Database Connections

The getting started code found in the `server/src/main/dataaccess/DatabaseManager.java` file reads the database configuration information from `db.properties` and contains a static function for creating database connections. The following code gives you an example of how you can use this code.

```java
public void example() throws Exception {
   try (var conn = DatabaseManager.getConnection()) {
      try (var preparedStatement = conn.prepareStatement("SELECT 1+1")) {
         var rs = preparedStatement.executeQuery();
         rs.next();
         System.out.println(rs.getInt(1));
      }
   }
}
```

Make sure that you wrap your calls to get a connection with a `try-with-resources` block so that the connection gets cleaned up.

## Initializing Your Database and Tables

As you design your database schema, carefully consider data types, primary and foreign keys, autogenerated IDs, default values, and whether a field can be `null`.

> [!TIP]
> On some operating systems, MySQL treats database and table names as case-sensitive, and on others it does not. For this reason you should always make sure your database, table, and field names match the case of your query statements so they will execute correctly on all operating systems, even if your development environment doesn't require it.

> [!TIP]
> The `DatabaseManager` class also has a method for creating a database if it does not exist. You are not required to use this code, but it is required that on start up, your code creates both your database and tables if they do not exist, based on the values configured in `db.properties`. This allows the pass off tests to run without manual intervention to set up your database.

> [!TIP]
> After your tables have created once, changing your `CREATE TABLE` statements will not actually affect the database. See [Changing Tables](../../instruction/db-sql/db-sql.md#changing-tables) for more information.

The [Pet Shop](../../petshop/server/src/main/dataaccess/MySqlDataAccess.java) provides an example of how to initialize your database on start up if you are wondering how this is done.

## Password Hashing

In order to protect the security of your user's password, you must encrypt their password using the bcrypt algorithm. When a user provides a password, hash it before storing it in the database.

```java
void storeUserPassword(String username, String clearTextPassword) {
   String hashedPassword = BCrypt.hashpw(clearTextPassword, BCrypt.gensalt());

   // write the hashed password in database along with the user's other information
   writeHashedPasswordToDatabase(username, hashedPassword);
}
```

Then when a user attempts to login, repeat the hashing process on the user supplied login password and then compare the resulting hash to the previously stored hash of the original password. If the two hashes match then you know the supplied password is correct.

```java
boolean verifyUser(String username, String providedClearTextPassword) {
   // read the previously hashed password from the database
   var hashedPassword = readHashedPasswordFromDatabase(username);

   return BCrypt.checkpw(providedClearTextPassword, hashedPassword);
}
```

The above code demonstrates the necessary concepts to implement secure password storage, but it will need to be adapted to your particular implementation. You do not need to create a different table to store your passwords. The hashed password may be stored along with your other user information in your `user` table.

## ChessGame Serialization/Deserialization

The easiest way to store the state of a ChessGame in MySQL is to serialize it to a JSON string, and then store the string in your database. Whenever your server needs to update the state of a game, it should:

1. Select the game’s state (JSON string) from the database
2. Deserialize the JSON string to a ChessGame Java object
3. Update the state of the ChessGame object
4. Re-serialize the Chess game to a JSON string
5. Update the game’s JSON string in the database

You will want to carefully consider the need for a Gson type adapter when you do your serialization. If your classes have any interface fields then you will need to tell Gson how to instantiate a concrete class for the interface when it is deserializing. You might want to review the [instruction](../../instruction/db-jdbc/db-jdbc.md) on this topic.

## Relevant Instruction Topics

- [JSON and Serialization](../../instruction/json/json.md): Serialization objects to the database.
- [Relational Databases](../../instruction/db-model/db-model.md): How relational databases work.
- [MYSQL](../../instruction/mysql/mysql.md): Getting MySQL installed.
- [SQL](../../instruction/db-sql/db-sql.md): Using SQL statements.
- [JDBC](../../instruction/db-jdbc/db-jdbc.md): Using SQL from Java including type adapters.

## ☑ Deliverable

### Pass Off Tests

The tests provided for this assignment are in the DatabaseTests class. These tests make HTTP requests to test your server.

Additionally, run the StandardAPITests from the previous phase to make sure they still run successfully.

### Database Unit Tests

The pass off tests do not examine your game board. That means it is critical that you write tests that fully test everything you are persisting to the database. This includes tests that store an initial board, add players, make moves, and update the game state.

As part of your unit test deliverable you need to meet the following requirements.

1. Write a positive and a negative JUNIT test case for each public method on your DAO classes, except for Clear methods which only need a positive test case. A positive test case is one for which the action happens successfully (e.g., creating a new user in the database). A negative test case is one for which the operation fails (e.g., creating a User that has the same username as an existing user).
1. Ensure that all of your unit tests work, including the new DAO tests and the Service tests you wrote in the previous assignment.

> [!IMPORTANT]
> You must place your data access test cases in a folder named server/src/test/java/dataaccess.

### Code Quality

For this phase the TAs will grade the quality of your project's source code. The rubric used to evaluate code quality can be found here: [Rubric](../code-quality-rubric.md)

### Pass Off, Submission, and Grading

All of the tests in your project must succeed in order to complete this phase.

To pass off this assignment use the course [auto-grading](https://cs240.click/) tool. If your code passes then your grade will automatically be entered in Canvas.

If your tests are passing locally but not on the autograder, here are some things to try:

- It's possible your server doesn't create the database and tables correctly when starting up. Drop your database/schema using an external tool (MySQL shell or workbench) and rerun the tests locally. If they fail, double check the code for creating the database and tables.
- Check for any place you may have hardcoded any values from db.properties. The auto-grader inserts a db.properties file with most of the values different from your file. The most common hardcoded value is the database name (commonly called `chess`). Check each SQL statement, including where you create tables, for the database name.
  For example, use `INSERT INTO table` instead of `INSERT INTO database.table`. The `getConnection` method inside `DatabaseManager` already sets up the connection to use your database so you shouldn't need to specify the database name if you are using that method to obtain your connections.
- If you develop on a machine running a Windows OS, double check the casing in all of your SQL statements. For example, if you have table `foobar`, your machine may accept `INSERT INTO FooBar`, but the auto-grader machine will not. Make sure each table and column name uses the same casing each time you use it.

### Grading Rubric

> [!IMPORTANT]
> You are required to commit to GitHub with every minor milestone. For example, after you successfully pass a test. This should result in a commit history that clearly details your work on this phase. If your Git history does not demonstrate your efforts then your submission may be rejected.

| Category       | Criteria                                                                                                                                                                            |       Points |
| :------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -----------: |
| GitHub History | At least 12 GitHub commits evenly spread over the assignment period that demonstrate proof of work                                                                                  | Prerequisite |
| Functionality  | All pass off test cases succeed                                                                                                                                                     |          100 |
| Code Quality   | [Rubric](../code-quality-rubric.md)                                                                                                                                                 |           30 |
| Unit Tests     | All test cases pass<br/>Each public method on DAO classes has two test cases, one positive test and one negative test<br/>Every test case includes an Assert statement of some type |           25 |
|                | Total                                                                                                                                                                               |          155 |

## <a name="videos"></a>Videos (29:30)

- 🎥 [Phase 4 Introduction (4:21)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=1d2253eb-f42c-4091-8d6f-b19301573278)
- 🎥 [Making Database Connections (6:22)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=9eb42a5d-6770-4d1a-a3ab-b1930158f0d3)
- 🎥 [Initializing Your Database and Tables (4:22)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=953900dc-0b8e-4ed8-a732-b193015b7e64)
- 🎥 [Password Hashing (4:14)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=671b0db7-323b-4bec-b0b7-b193015cf733)
- 🎥 [ChessGame Serialization/Deserialization (6:17)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=5b9f4b5e-a3ae-442f-a311-b193015f1b34)
- 🎥 [Database Unit Tests (1:52)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=ab5a02c1-bf04-4514-afc0-b19301611d40)
- 🎥 [Grading Rubric (2:02)](https://byu.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=1b8d4c3b-1e76-4474-9007-b19301620058)
